---
layout: post
title: "c重点习题" 
---

循环-04. 验证“哥德巴赫猜想”(20)

数学领域著名的“哥德巴赫猜想”的大致意思是：任何一个大于2的偶数总能表示为两个素数之和。比如：24=5+19，其中5和19都是素数。本实验的任务是设计一个程序，验证20亿以内的偶数都可以分解成两个素数之和。

输入格式：

输入在一行中给出一个(2, 2 000 000 000]范围内的偶数N。

输出格式：

在一行中按照格式“N = p + q”输出N的素数分解，其中p <= q均为素数。又因为这样的分解不唯一（例如24还可以分解为7+17），要求必须输出所有解中p最小的解。

输入样例：

24

输出样例：

24 = 5 + 19

	#include <stdio.h>
	#include<math.h>


	long long isPrime(long long n){
	long long i,sign=1;
	for(i=2;i<=sqrt(n);i++){
	if(n%i==0){
    sign=0;
	}
	}

	return sign;
	}

	int main(void) {
	long long N,p=2,q=2;
	scanf("%lld",&N);
	
		for(;p<=(N-p);p++){
	
		if(isPrime(p)&&isPrime((N-p))){
		
			printf("%lld = %lld + %lld",N,p,N-p);
			break;
		}
			
					}
	return 0;
	}



【描述】

水仙花数是指一个N位正整数（N>=3），它的每个位上的数字的N次幂之和等于它本身。例 如：153 = 13 + 53 + 33。 本题要求编写程序,计算所有N位水仙花数。

【输入】

输入在一行中给出一个正整数N（3<=N<=7）。

【输出】

按递增顺序输出所有N位水仙花数，每个数字占一行。

【输入示例】

3

【输出示例】

153

370

371

407

	#include<stdio.h>

	int powI(int n,int N){
	int sum;
	for(sum=1;N>=1;N--){
		sum=sum*n;
	}
	return sum; //忘记return sum了！
	}

	int main(){
	int N,sum,i,n,SUM=0,a,b;
	scanf("%d",&N);
	// n=pow(10,N-1);不要用pow，在PAT里测试，速度相当慢，还通不过测试。自己写循环来算。 
	b=N;
	for(a=1;b>1;b--){
		a*=10;
	}
	
	sum=a;
	n=a;
	while(n<a*10){
		
	while(sum!=0){
		i=sum%10;
		SUM=SUM+powI(i,N);
		sum=sum/10;
	}
	
	if(n==SUM)
		printf("%d\n",SUM);
		
	SUM=0;
	n++;
	sum=n;
	
	}

	return 0;
	}




【描述】

给定平面上任意三个点的坐标(x1,y1)、(x2,y2)、(x3,y3)，检验它们能否构成三角形。

【输入】

输入在一行中顺序给出6个[-100, 100]范围内的数字，即3个点的坐标x1, y1, x2, y2, x3, y3。

【输出】

若这3个点不能构成三角形，则在一行中输出“Impossible”；若可以，则在一行中输出该三角形的周长和面积，格式为“L = 周长, A = 面积”，输出到小数点后2位。

【输入示例1】

4 5 6 9 7 8

【输出示例1】

L = 10.13, A = 3.00

【输入示例2】

4 6 8 12 12 18

【输出示例】

Impossible



	#include<stdio.h>
	#include<math.h>
	int main(){
	double x1,y1,x2,y2,x3,y3,l1,l2,l3,p;
	scanf("%lf%lf%lf%lf%lf%lf",&x1,&y1,&x2,&y2,&x3,&y3);
	 if((x1-x2)/(y1-y2)!=(x2-x3)/(y2-y3)){
	 	l1=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)),l2=sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3)),l3=sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));
	 	p=(l1+l2+l3)/2;
	 	printf("L = %.2f, A = %.2f",sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))+//，后面有空格 
		 						sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3))+
								 sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3)),
								 sqrt(p*(p-l1)*(p-l2)*(p-l3))//海伦公式 
								 );
	 }
	 
	 else
	 printf("Impossible");
	

	return 0;
	}





